---
title: 'Semana 01'
---

import Title from '../../components/Title';
import Code from '../../components/CodeSyntax.astro';
import List from '../../components/List';
import CodeSandpack from '../../components/CodeSandpack';

<Title title={frontmatter.title} />

# Paréntesis válidos

Dada una cadena **s** que sólo contiene los caracteres `(`, `)`, `{`, `}`, `[` y `]`, determine si la cadena de entrada es válida.

Una cadena de entrada es válida si

<List
  items={[
    'Los corchetes abiertos deben estar cerrados por el mismo tipo de corchetes.',
    'Los corchetes abiertos deben cerrarse en el orden correcto.',
    'Cada corchete cerrado tiene su correspondiente corchete abierto del mismo tipo.',
  ]}
/>

## Ejemplos

### Ejemplo 1:

<Code
  code={`Input: s = "()"
Output: true`}
/>

### Ejemplo 2:

<Code
  code={`Input: s = "()[]{}"
Output: true`}
/>

### Ejemplo 3:

<Code
  code={`Input: s = "(]"
Output: false`}
/>

## Link del problema

[Link](https://leetcode.com/problems/valid-parentheses/)

## Mi solucion

<CodeSandpack
  client:load
  code={`/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  let stack = [];
  for (let z of s) {
    if (z === '(' || z === '[' || z === '{') {
      stack.push(z);
    } else {
      let latest = stack[stack.length - 1];
      console.log(latest);
      if (
        (z === ')' && latest === '(') ||
        (z === ']' && latest === '[') ||
        (z === '}' && latest === '{')
      ) {
        stack.pop();
      } else {
        return false;
      }
    }
  }
  return stack.length === 0
};
`}
/>

# Encantos de Elyses

Como futura maga, Elyse necesita practicar algunos trucos básicos. Tiene una pila de cartas que quiere manipular.

Para facilitar las cosas, sólo utiliza las cartas del 1 al 10, de modo que su pila de cartas puede representarse mediante una matriz de números. La posición de una carta determinada corresponde a su índice en la matriz. Esto significa que la posición 0 se refiere a la primera carta, la posición 1 a la segunda carta, etc.

## Tarea 1: Recuperar una tarjeta de una pila

Para elegir una carta, devuelve la carta en la posición índice de la pila dada.

```js
const position = 2;
getItem([1, 2, 4, 1], position);
// => 4
```

### Mi solucion

<CodeSandpack
  code={`function getItem(cards, position) {
  return cards[position]
}`}
  client:load
/>

## Tarea 2: Cambiar una carta de la pila

Realice algún juego de manos e intercambie la carta en la posición del índice con la carta de sustitución suministrada. Devuelve la pila ajustada.

```js
const position = 2;
const replacementCard = 6;
setItem([1, 2, 4, 1], position, replacementCard);
// => [1, 2, 6, 1]
```

### Mi solucion

<CodeSandpack
  code={`function setItem(cards, position, replacementCard) {
  cards.splice(position, 1, replacementCard)
  return cards
}`}
  client:load
/>

## Tarea 3: Inserte una carta en la parte superior de la pila

Haga aparecer una carta insertando una nueva carta en la parte superior de la pila. Devuelve la pila ajustada.

```js
const newCard = 8;
insertItemAtTop([5, 9, 7, 1], newCard);
// => [5, 9, 7, 1, 8]
```

### Mi solucion

<CodeSandpack
  code={`function insertItemAtTop(cards, newCard) {
  cards.push(newCard)
  return cards
}`}
  client:load
/>

## Tarea 4: Retirar una carta de la pila

Hacer desaparecer una carta eliminando la carta en la posición dada de la pila. Devuelve la pila ajustada.

```js
const position = 2;
removeItem([3, 2, 6, 4, 8], position);
// => [3, 2, 4, 8]
```

### Mi solucion

<CodeSandpack
  code={`function removeItem(cards, position) {
  cards.splice(position, 1)
  return cards
}`}
  client:load
/>

## Tarea 5: Retira la carta superior de la pila

Haga desaparecer una carta retirando la carta de la parte superior de la pila. Devuelve la pila ajustada.

```js
removeItemFromTop([3, 2, 6, 4, 8]);
// => [3, 2, 6, 4]
```

### Mi solucion

<CodeSandpack
  code={`function removeItemFromTop(cards) {
  cards.pop()
  return cards
}`}
  client:load
/>

## Tarea 6: Inserte una carta en la parte inferior de la pila

Haga aparecer una carta insertando una nueva carta en la parte inferior de la pila. Devuelve la pila ajustada.

```js
const newCard = 8;
insertItemAtBottom([5, 9, 7, 1], newCard);
// => [8, 5, 9, 7, 1]
```

### Mi solucion

<CodeSandpack
  code={`function insertItemAtBottom(cards, newCard) {
  cards.unshift(newCard)
  return cards
}`}
  client:load
/>

## Tarea 7: Retirar una carta del fondo de la pila

Haga desaparecer una carta retirando la carta de la parte inferior de la pila. Devuelve la pila ajustada.

```js
removeItemAtBottom([8, 5, 9, 7, 1]);
// => [5, 9, 7, 1]
```

### Mi solucion

<CodeSandpack
  code={`function removeItemAtBottom(cards) {
  cards.shift()
  return cards
}`}
  client:load
/>

## Tarea 8: Comprobar el tamaño de la pila

Comprueba si el tamaño de la pila es igual o no a stackSize.

```js
const stackSize = 4;
checkSizeOfStack([3, 2, 6, 4, 8], stackSize);
// => false
```

### Mi solucion

<CodeSandpack
  code={`function checkSizeOfStack(cards, stackSize) {
  if(cards.length === stackSize){
    return true
  } else {
    return false
  }
}`}
  client:load
/>

# Crear numero telefonico

Escribe una funcion que acepte un array de 10 enteros (entre 0 y 9), que devuelva un string de esos numeros en formato de numero telefonico.

## Ejemplo

```js
createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]); // => returns "(123) 456-7890"
```

El formato debe ser el correcto para resolver el desafio.

No te olvides del espacio despues del cierre de parentesis!

## Link al problema

[Link](https://www.codewars.com/kata/525f50e3b73515a6db000b83/train/javascript)

## Mi solucion

```js
function createPhoneNumber(numbers) {
  const caracteristica = numbers.splice(0, 3).join('');
  const firstNumbers = numbers.splice(0, 3).join('');
  const secondNumbers = numbers.splice(0, 4).join('');
  return `(${caracteristica}) ${firstNumbers}-${secondNumbers}`;
}
```

# Concatenacion de un array

Dado un array de enteros `nums` de longitud n, necesitas crear un array de longitud 2n donds `ans[i] == nums[i]` y `ans[i + n] === nums[i]` para `0 <= i < n` (0-indexed).

Especificamente, `ans` es la concatenacion de dos arrays `nums`.

Devolver el array `ans`.

## Ejemplo 1

```
Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
```

## Ejemplo 2

```
Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
```

## Limitantes

<List items={['n == nums.length', '1 <= n <= 1000', '1 <= nums[i] <= 1000']} />

## Link al problema

[Link](https://leetcode.com/problems/concatenation-of-array/description/)

## Mi solucion

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var getConcatenation = function (nums) {
  return [...nums, ...nums];
};
```

# Compra de vehiculo

En este desafio tendras que escribir codigo para comprar un vehiculo.

Tienes 3 tareas, una determina si vas a necesitar una licencia, otra te ayudara a elegir entre dos vehiculos y una tercera estimara el precio aceptable para un vehiculo usado.

## Tarea 1: Determina si necesitaras una licencia de conducir

Algunos vehiculos necesitan de una licencia de conducir para operarlos. Asumiendo que solo los vehiculos "car" y "truck" requieren de la licencia, los demas pueden conducirse sin la licencia.

Implementa la funcion `needsLicense(kind)` que toma el tipo (kind) de vehiculo y devuelve un booleano indicando si necesitas o no la licencia para ese tipo de vehiculo.

```js
needsLicense('car');
// => true

needsLicense('bike');
// => false
```

### Mi solucion

```js
function needsLicense(kind) {
  if (kind === 'car' || kind === 'truck') {
    return true;
  } else {
    return false;
  }
}
```

## Tarea 2: Elige entre dos vehiculos potenciales para comprar

Evaluarias tus opciones de vehiculos disponibles. Haz llego a decidirte entre dos opciones pero necesitaras ayuda para hacer la decision final. Para esto implementaras la funcion `chooseVehicle(option1, option2)` que toma los dos vehiculos como argumentos y devuelve una decision que incluye la opcion que esta primero en el orden alfabetico.

```js
chooseVehicle('Wuling Hongguang', 'Toyota Corolla');
// =>  'Toyota Corolla is clearly the better choice.'

chooseVehicle('Volkswagen Beetle', 'Volkswagen Golf');
// =>  'Volkswagen Beetle is clearly the better choice.'
```

### Mi solucion

```js
function chooseVehicle(option1, option2) {
  if (option1 < option2) {
    return `${option1} is clearly the better choice.`;
  } else {
    return `${option2} is clearly the better choice.`;
  }
}
```

## Tarea 2: Calcular una estimacion para el precio de un vehiculo usado

Ahora que ha tomado una decisión, quiere asegurarse de que le ofrecen un precio justo en el concesionario. Dado que estás interesado en comprar un vehículo usado, el precio depende de la antigüedad del vehículo. Para hacer una estimación aproximada, supongamos que si el vehículo tiene menos de 3 años, cuesta el 80% del precio original que tenía cuando era nuevo. Si tiene más de 10 años, cuesta el 50%. Si el vehículo tiene al menos 3 años pero no más de 10, cuesta el 70% del precio original.

Implementa la función `calculateResellPrice(originalPrice, age)` que aplica esta lógica usando if, else if y else. Toma como argumentos el precio original y la antigüedad del vehículo y devuelve el precio estimado en el concesionario.

```js
calculateResellPrice(1000, 1);
// => 800

calculateResellPrice(1000, 5);
// => 700

calculateResellPrice(1000, 15);
// => 500
```

### Mi solucion

```js
function calculateResellPrice(originalPrice, age) {
  if (age < 3) {
    return (80 * originalPrice) / 100;
  } else if (age <= 10) {
    return (70 * originalPrice) / 100;
  } else {
    return (50 * originalPrice) / 100;
  }
}
```

# 1, 0 y comodines

Dado un string que contiene ceros y unos, y un "?", donde este "?" es un comodin por lo cual puede ser 0 o 1.

Devolver un array conteniendo todas las posibilidades que puede tener el subtituto de "?".

You are given a string containing 0's, 1's and one or more '?', where ? is a wildcard that can be 0 or 1.

Return an array containing all the possibilities you can reach substituing the ? for a value.

## Ejemplos

```js
'101?' -> ['1010', '1011']

'1?1?' -> ['1010', '1110', '1011', '1111']
```

## Notes

- No te preocupes por ordenar el array.
- El string nunca estara vacio.
- Diviertete!

## Mi solucion

```js
function possibilities(str) {
  let arr = [];

  const stack = [];

  stack.push(str);

  let index;

  while (stack.length) {
    let curr = stack.pop();
    if ((index = curr.indexOf('?')) !== -1) {
      for (let c = 0; c <= 1; c++) {
        curr = curr.substring(0, index) + c + curr.substring(index + 1);
        stack.push(curr);
      }
    } else {
      arr.push(curr);
    }
  }
  return arr;
}
```

{/* Ta bueno para una explicacion */}

# Convertir un string a Camel Case

Complete el método/función para que convierta las palabras delimitadas por guiones/guiones bajos en mayúsculas y minúsculas. La primera palabra de la salida debe ir en mayúsculas sólo si la palabra original iba en mayúsculas (lo que se conoce como Mayúsculas Camel Case, también conocido como Pascal case). Las palabras siguientes deben ir siempre en mayúsculas.

## Ejemplos

```
"the-stealth-warrior" gets converted to "theStealthWarrior"
"The_Stealth_Warrior" gets converted to "TheStealthWarrior"
```

## Mi solucion

```js
function toCamelCase(str) {
  let stack = [];
  let transformed = str.replaceAll('_', '-');
  let splitted = transformed.split('-');
  stack.push(splitted[0]);
  for (let i = 1; i < splitted.length; i++) {
    stack.push(splitted[i][0].toUpperCase() + splitted[i].substring(1));
  }
  return stack.join('');
}
```
